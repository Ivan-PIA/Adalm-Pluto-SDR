# Exams

## Задание №1

Входные параметры:
N – число бит, четное значение (например, 50)
Fs – частота дискретизации (например, 500 000 семплов в сек)
Ns – число семплов на 1 модуляционный символ (например, 10/30/50/100 семплов на символ)
Несущая частота – 900 МГц

Передатчик:
1.	Сформируйте случайную битовую последовательность из N бит (вх.параметр)
2.	Добавьте 20 бит с единицами, выполняющих роль синхронизирующей последовательности, а также опорных пилотных сигналов, по которым можно будет оценить изменение фазы полученного сигнала
3.	Сформируйте массив комплексных QPSK-символов. Длительность одного символа равна Ns отсчетов
4.	Зациклите буфер с символами на передачу и отправьте в радиоэфир
5.	Выведите на график временное и частотное представление сформированного сигнала

Приемник:
1.	Запишите входной сигнал в массив 
2.	Выведите на график временное и частотное представление сформированного сигнала. Проанализируйте влияние длительности передаваемого символа на ширину спектра, изменяя параметр Ns (уменьшить и увеличить, вывести график трех спектров: для Ns, Ns/2 и Ns*2)
3.	Определите время начала последовательности с учетом ваших знаний о синхронизирующей последовательности.
4.	Выведите на комплексной плоскости координаты полученных значений (перекрученные созвездия)
5.	Проанализируйте изменение фазы сигналов, используя символы синхронизирующей последовательности и компенсируйте данное изменение для информационных символов (разверните созвездия на верные позиции для последующей демодуляции)
6.	Выполните демодуляцию полученных символов, сравните переданную и полученную битовые последовательности, определите количество ошибок.



## Реализация

1. Сформировали массив длинной 50 из рандомных значений от 0 до 3 и закодировали каждый символ 2 битами

```py
x_int = np.random.randint(0, 4, num_symbols) 
bit = ''
for i in range(len(x_int)):
        if x_int[i]==0:
            bit+='00'
        if x_int[i]==1:
            bit+='01'
        if x_int[i]==2:
            bit+='10' 
        if x_int[i]==3:
            bit+='11'
```
далее мы все равно отправляем не эти биты а просто набор символов переведенные в фазу и далее в комплексные числа (Не успел реализовать)

2. Превращаем значения в комплексные числа
```py
x_symbols = np.cos(x_radians) + 1j*np.sin(x_radians) 
samples = np.repeat(x_symbols, Ns) # на каждый символ уходит Ns samples 
samples *= 2**14                   #увеличиваем амплитуду 
```
- Наши данные: 

*Во временном представлении:*

<img src = "photo/t1_time.png">

*В частотном представлении:*

<img src = "photo/Figure_33.png">



- Наши данные в разделении на реальную и мнимую этот вид и подаем на передатчик:

<img src = "photo/Figure_22.png">

3. Организовываем передатчик

```py
def Txer(data): # Отправка данных
    while 1:       #зациклил while т.к. sdr.tx_cyclic_buffer быстро завершал отправку
        sdr.tx(data)
        sdr.tx_destroy_buffer()
        print(1)
```
4. Организовываем приемник
```py
def listen_efir(data):   # Прием данных в реальном времени
   
    for r in range(50):
        sdr.tx(data)
        sdr.tx_destroy_buffer()
        rx_data = sdr.rx()
        plt.clf()
        plt.scatter(rx_data.real,rx_data.imag)
        plt.draw()
        plt.xlabel('Гц')
        plt.ylabel('$x[k]$')
        plt.pause(0.05)
        time.sleep(0.1)
```        

- Неудачные попытки приема 

<img src = "photo/deb.jpg">

- Еще немного

<img src = "photo/deb2.jpg">


Тут более похоже на QPSK сигнал

- Самые мало-зашумленные сигналы принимались и предавались на одной SDR

<img src = "photo/deb3.jpg">

5. Декодировать сигнал неуспел

